"""
Simple ADK Agent API Server

A FastAPI server exposing ADK agent functionality via HTTP endpoints.
Uses in-memory services for simplicity. Client applications make HTTP requests to interact.
"""

import asyncio
import json
import logging
import os
import sys

from agent1 import root_agent
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, StreamingResponse
from google.adk.agents import Agent
from google.adk.runners import InMemoryRunner, Runner
from google.adk.sessions import InMemorySessionService
from google.genai import types
from utilities import (clean_json_response, create_event_summary,
                       generate_home_page_html, get_client_url, log_event,
                       log_session)

load_dotenv()

# ============================================================================
# Configure logging
# ============================================================================

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ============================================================================
# Read Configuration
# ============================================================================

APP_NAME = os.getenv("APP_NAME", "adk_agent_app")
GOOGLE_CLOUD_PROJECT = os.getenv("GOOGLE_CLOUD_PROJECT", "my-gcp-project")
GOOGLE_CLOUD_LOCATION = os.getenv("GOOGLE_CLOUD_LOCATION", "us-central1")
SESSION_SERVICE_PROVIDER = os.getenv("SESSION_SERVICE_PROVIDER", "in_memory")
REASONING_ENGINE_APP_NAME = os.getenv("REASONING_ENGINE_APP_NAME", "reasoning_engine_app")
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./test.db")

# ============================================================================
# ADK Session Setup
# ============================================================================

# Create the session service
if SESSION_SERVICE_PROVIDER == "in_memory":
    session_service = InMemorySessionService()
elif SESSION_SERVICE_PROVIDER == "vertex":
    # STUDENT TASK: Implement VertexSessionService
    # Reference: https://google.github.io/adk-docs/sessions/session/#sessionservice-implementations
    # 1. import class
    # 2. create session_service instance
    # 3. remove pass statement
    from google.adk.sessions import VertexAiSessionService
    session_service = VertexAiSessionService(project=GOOGLE_CLOUD_PROJECT, location=GOOGLE_CLOUD_LOCATION)
    print('VertexAiSessionService initialized')
    # pass
elif SESSION_SERVICE_PROVIDER == "db":
    # STUDENT TASK: Implement DatabaseSessionService
    # 1. import class
    # 2. create session_service instance
    from google.adk.sessions import DatabaseSessionService
    db_url = DATABASE_URL
    session_service = DatabaseSessionService(db_url=db_url)
    print('DatabaseSessionService initialized')
    # 3. remove pass statement
    # pass
else:
    logger.error(f"Unsupported SESSION_SERVICE_PROVIDER: {SESSION_SERVICE_PROVIDER}")
    sys.exit(1)


# ============================================================================
# ADK Runner Setup
# ============================================================================

# Create the runner
runner = Runner(
    app_name=APP_NAME,
    agent=root_agent,
    session_service=session_service
)


# ============================================================================
# FastAPI Setup
# ============================================================================

app = FastAPI(title="ADK Agent Server", version="1.0.0")

# Add CORS middleware to allow requests from any origin for development/testing
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all HTTP methods (GET, POST, PUT, DELETE, etc.)
    allow_headers=["*"],  # Allows all headers in the request
)


# ============================================================================
# API Endpoints
# ============================================================================

@app.post("/sessions")
async def create_session(request: dict):
    """Create a new session for a user."""
    session = await session_service.create_session(
        app_name=APP_NAME,
        user_id=request["user_id"],
        state=request.get("initial_state", {})
    )
    return {
        "session_id": session.id,
        "user_id": session.user_id
    }


@app.post("/chat")
async def chat(request: dict):
    """Send a message to the agent and get a response with streaming session updates."""
    # Handle session - create if not provided, error if provided but not found
    session_id = request.get("session_id")
    user_id = request["user_id"]
    
    if not session_id:
        # No session ID provided - create a new session
        logger.info(f"No session ID provided, creating new session for user {user_id}")
        session = await session_service.create_session(
            app_name=APP_NAME,
            user_id=user_id,
            state={}
        )
        session_id = session.id
    else:
        # Session ID provided - verify it exists
        session = await session_service.get_session(
            app_name=APP_NAME,
            user_id=user_id,
            session_id=session_id
        )
        
        if not session:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid session_id: '{session_id}' not found for user '{user_id}'. Session may have expired or been deleted."
            )
    
    # Package the message in the correct ADK format
    user_message = types.Content(
        role="user",
        parts=[types.Part(text=request["message"])]
    )
    
    async def event_generator():
        """Generate SSE events for both session cards and final response."""
        final_response_text = None
        event_index = 0
        
        # Run the agent using run_async - it returns a generator of events
        async for event in runner.run_async(
            user_id=user_id,
            session_id=session_id,
            new_message=user_message
        ):            
            # Get current session state
            current_session = await session_service.get_session(
                app_name=APP_NAME,
                user_id=user_id,
                session_id=session_id
            )
            
            # Create summaries for all events in session
            all_events_summary = []
            for idx, evt in enumerate(current_session.events):
                all_events_summary.append(create_event_summary(evt, idx))
            
            # Create and send session card update for this event
            session_card_data = {
                "type": "session_card",
                "session": {
                    "session_id": current_session.id,
                    "app_name": current_session.app_name,
                    "user_id": current_session.user_id,
                    "state": current_session.state,
                    "events_count": len(current_session.events),
                    "last_update_time": str(current_session.last_update_time)
                },
                "events": all_events_summary
            }
            yield f"data: {json.dumps(session_card_data)}\n\n"
            
            event_index += 1
            
            # Capture the final response text when available
            if event.is_final_response() and event.content and event.content.parts:
                final_response_text = event.content.parts[-1].text
                break
        
        # Get final session state
        updated_session = await session_service.get_session(
            app_name=APP_NAME,
            user_id=user_id,
            session_id=session_id
        )

        # await memory_service.add_session_to_memory(updated_session)
        
        # Prepare session summary
        session_summary = {
            "session_id": updated_session.id,
            "app_name": updated_session.app_name,
            "user_id": updated_session.user_id,
            "state": updated_session.state,
            "events_count": len(updated_session.events),
            "last_update_time": updated_session.last_update_time
        }
        
        # If no final response text was produced, raise an error
        if final_response_text is None:
            logger.error("Agent pipeline did not produce a final text response")
            error_data = {
                "type": "error",
                "message": "Agent pipeline did not produce a final text response."
            }
            yield f"data: {json.dumps(error_data)}\n\n"
            return
        
        # Send final response
        final_data = {
            "type": "final_response",
            "response": final_response_text,
            "session": session_summary
        }
        yield f"data: {json.dumps(final_data)}\n\n"
    
    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
        }
    )


@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    """Home page with link to client application."""
    client_url = get_client_url(str(request.base_url))
    return HTMLResponse(content=generate_home_page_html(client_url))

if __name__ == "__main__":
    import uvicorn

    # Run the FastAPI application using Uvicorn
    uvicorn.run(
        "session_agent_server:app",  # Import string format for reload to work
        host="0.0.0.0",
        port=8000,
        reload=True
    )